/** @license React vundefined
 * react-events-scroll.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react')) :
	typeof define === 'function' && define.amd ? define(['react'], factory) :
	(global.ReactEventsScroll = factory(global.React));
}(this, (function (React) { 'use strict';

var UserBlockingEvent = 1;

var targetEventTypes = ['scroll', 'pointerdown', 'keyup'];
var rootEventTypes = ['pointermove', 'pointerup', 'pointercancel'];

function createScrollEvent(event, context, type, target, pointerType) {
  var clientX = null;
  var clientY = null;
  var pageX = null;
  var pageY = null;
  var screenX = null;
  var screenY = null;

  if (event) {
    var nativeEvent = event.nativeEvent;
    clientX = nativeEvent.clientX;
    clientY = nativeEvent.clientY;
    pageX = nativeEvent.pageX;
    pageY = nativeEvent.pageY;
    screenX = nativeEvent.screenX;
    screenY = nativeEvent.screenY;
  }

  return {
    target: target,
    type: type,
    pointerType: pointerType,
    direction: '', // TODO
    timeStamp: context.getTimeStamp(),
    clientX: clientX,
    clientY: clientY,
    pageX: pageX,
    pageY: pageY,
    screenX: screenX,
    screenY: screenY,
    x: clientX,
    y: clientY
  };
}

function dispatchEvent(event, context, state, name, listener, eventPriority) {
  var target = state.scrollTarget;
  var pointerType = state.pointerType;
  var syntheticEvent = createScrollEvent(event, context, name, target, pointerType);
  context.dispatchEvent(syntheticEvent, listener, eventPriority);
}

var ScrollResponder = {
  displayName: 'Scroll',
  targetEventTypes: targetEventTypes,
  createInitialState: function () {
    return {
      pointerType: '',
      scrollTarget: null,
      isPointerDown: false
    };
  },

  allowMultipleHostChildren: true,
  allowEventHooks: true,
  onEvent: function (event, context, props, state) {
    var pointerType = event.pointerType,
        target = event.target,
        type = event.type;


    if (props.disabled) {
      if (state.isPointerDown) {
        state.isPointerDown = false;
        state.scrollTarget = null;
        context.addRootEventTypes(rootEventTypes);
      }
      return;
    }

    switch (type) {
      case 'scroll':
        {
          state.scrollTarget = target;
          if (props.onScroll) {
            dispatchEvent(event, context, state, 'scroll', props.onScroll, UserBlockingEvent);
          }
          break;
        }
      case 'keyup':
        {
          state.pointerType = pointerType;
          break;
        }
      case 'pointerdown':
        {
          state.pointerType = pointerType;
          if (!state.isPointerDown) {
            state.isPointerDown = true;
            context.addRootEventTypes(rootEventTypes);
          }
          break;
        }
    }
  },
  onRootEvent: function (event, context, props, state) {
    var pointerType = event.pointerType,
        type = event.type;


    switch (type) {
      case 'pointercancel':
      case 'pointerup':
        {
          state.pointerType = pointerType;
          if (state.isPointerDown) {
            state.isPointerDown = false;
            context.removeRootEventTypes(rootEventTypes);
          }
          break;
        }
      case 'pointermove':
        {
          state.pointerType = pointerType;
        }
    }
  },
  onUnmount: function (context, props, state) {
    // TODO
  },
  onOwnershipChange: function (context, props, state) {
    // TODO
  }
};

var Scroll = React.unstable_createEvent(ScrollResponder);

function useScroll(props) {
  React.unstable_useEvent(Scroll, props);
}

var Scroll$1 = Object.freeze({
	Scroll: Scroll,
	useScroll: useScroll
});

var scroll = Scroll$1;

return scroll;

})));
