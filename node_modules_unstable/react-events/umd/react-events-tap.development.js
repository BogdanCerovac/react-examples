/** @license React vundefined
 * react-events-tap.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react')) :
	typeof define === 'function' && define.amd ? define(['react'], factory) :
	(global.ReactEventsTap = factory(global.React));
}(this, (function (React) { 'use strict';

var ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
var _assign = ReactInternals.assign;

var DiscreteEvent = 0;
var UserBlockingEvent = 1;

var hasPointerEvents = typeof window !== 'undefined' && window.PointerEvent !== undefined;
var isMac = typeof window !== 'undefined' && window.navigator != null ? /^Mac/.test(window.navigator.platform) : false;
var buttonsEnum = {
  none: 0,
  primary: 1,
  secondary: 2,
  middle: 4
};
function dispatchDiscreteEvent(context, payload, callback) {
  context.dispatchEvent(payload, callback, DiscreteEvent);
}
function dispatchUserBlockingEvent(context, payload, callback) {
  context.dispatchEvent(payload, callback, UserBlockingEvent);
}

/**
 * Native event dependencies
 */
var targetEventTypes = hasPointerEvents ? ['pointerdown'] : ['mousedown', 'touchstart'];
var rootEventTypes = hasPointerEvents ? ['click_active', 'contextmenu', 'pointerup', 'pointermove', 'pointercancel', 'scroll'] : ['click_active', 'contextmenu', 'mouseup', 'mousemove', 'dragstart', 'touchend', 'touchmove', 'touchcancel', 'scroll'];
/**
 * Responder and gesture state
 */

function createInitialState() {
  return {
    activePointerId: null,
    buttons: 0,
    ignoreEmulatedEvents: false,
    isActive: false,
    pointerType: '',
    responderTarget: null,
    rootEvents: null,
    shouldPreventClick: true,
    gestureState: {
      altKey: false,
      buttons: 0,
      ctrlKey: false,
      height: 1,
      metaKey: false,
      pageX: 0,
      pageY: 0,
      pointerType: '',
      pressure: 0,
      screenX: 0,
      screenY: 0,
      shiftKey: false,
      tangentialPressure: 0,
      target: null,
      tiltX: 0,
      tiltY: 0,
      timeStamp: 0,
      twist: 0,
      width: 1,
      x: 0,
      y: 0
    }
  };
}

function createPointerEventGestureState(context, props, state, event) {
  var timeStamp = context.getTimeStamp();
  var nativeEvent = event.nativeEvent;
  var altKey = nativeEvent.altKey,
      ctrlKey = nativeEvent.ctrlKey,
      height = nativeEvent.height,
      metaKey = nativeEvent.metaKey,
      pageX = nativeEvent.pageX,
      pageY = nativeEvent.pageY,
      pointerType = nativeEvent.pointerType,
      pressure = nativeEvent.pressure,
      screenX = nativeEvent.screenX,
      screenY = nativeEvent.screenY,
      shiftKey = nativeEvent.shiftKey,
      tangentialPressure = nativeEvent.tangentialPressure,
      tiltX = nativeEvent.tiltX,
      tiltY = nativeEvent.tiltY,
      twist = nativeEvent.twist,
      width = nativeEvent.width,
      clientX = nativeEvent.clientX,
      clientY = nativeEvent.clientY;
  return {
    altKey: altKey,
    buttons: state.buttons,
    ctrlKey: ctrlKey,
    height: height,
    metaKey: metaKey,
    pageX: pageX,
    pageY: pageY,
    pointerType: pointerType,
    pressure: pressure,
    screenX: screenX,
    screenY: screenY,
    shiftKey: shiftKey,
    tangentialPressure: tangentialPressure,
    target: state.responderTarget,
    tiltX: tiltX,
    tiltY: tiltY,
    timeStamp: timeStamp,
    twist: twist,
    width: width,
    x: clientX,
    y: clientY
  };
}

function createFallbackGestureState(context, props, state, event) {
  var timeStamp = context.getTimeStamp();
  var nativeEvent = event.nativeEvent;
  var eType = event.type;
  var altKey = nativeEvent.altKey,
      ctrlKey = nativeEvent.ctrlKey,
      metaKey = nativeEvent.metaKey,
      shiftKey = nativeEvent.shiftKey;
  var isCancelType = eType === 'dragstart' || eType === 'touchcancel';
  var isEndType = eType === 'mouseup' || eType === 'touchend';
  var isTouchEvent = event.pointerType === 'touch';
  var pointerEvent = nativeEvent;

  if (!hasPointerEvents && isTouchEvent) {
    var touch = getTouchById(nativeEvent, state.activePointerId);

    if (touch != null) {
      pointerEvent = touch;
    }
  }

  var _pointerEvent = pointerEvent,
      pageX = _pointerEvent.pageX,
      pageY = _pointerEvent.pageY,
      radiusX = _pointerEvent.radiusX,
      radiusY = _pointerEvent.radiusY,
      rotationAngle = _pointerEvent.rotationAngle,
      screenX = _pointerEvent.screenX,
      screenY = _pointerEvent.screenY,
      clientX = _pointerEvent.clientX,
      clientY = _pointerEvent.clientY;
  return {
    altKey: altKey,
    buttons: state.buttons != null ? state.buttons : 1,
    ctrlKey: ctrlKey,
    height: !isCancelType && radiusY != null ? radiusY * 2 : 1,
    metaKey: metaKey,
    pageX: isCancelType ? 0 : pageX,
    pageY: isCancelType ? 0 : pageY,
    pointerType: event.pointerType,
    pressure: isEndType || isCancelType ? 0 : isTouchEvent ? 1 : 0.5,
    screenX: isCancelType ? 0 : screenX,
    screenY: isCancelType ? 0 : screenY,
    shiftKey: shiftKey,
    tangentialPressure: 0,
    target: state.responderTarget,
    tiltX: 0,
    tiltY: 0,
    timeStamp: timeStamp,
    twist: rotationAngle != null ? rotationAngle : 0,
    width: !isCancelType && radiusX != null ? radiusX * 2 : 1,
    x: isCancelType ? 0 : clientX,
    y: isCancelType ? 0 : clientY
  };
}

var createGestureState = hasPointerEvents ? createPointerEventGestureState : createFallbackGestureState;
/**
 * Managing root events
 */

function addRootEventTypes(rootEvents, context, state) {
  if (!state.rootEvents) {
    state.rootEvents = rootEvents;
    context.addRootEventTypes(state.rootEvents);
  }
}

function removeRootEventTypes(context, state) {
  if (state.rootEvents != null) {
    context.removeRootEventTypes(state.rootEvents);
    state.rootEvents = null;
  }
}
/**
 * Managing pointers
 */


function getTouchById(nativeEvent, pointerId) {
  if (pointerId != null) {
    var changedTouches = nativeEvent.changedTouches;

    for (var i = 0; i < changedTouches.length; i++) {
      var touch = changedTouches[i];

      if (touch.identifier === pointerId) {
        return touch;
      }
    }

    return null;
  }

  return null;
}

function getHitTarget(event, context, state) {
  if (!hasPointerEvents && event.pointerType === 'touch') {
    var doc = context.getActiveDocument();
    var nativeEvent = event.nativeEvent;
    var touch = getTouchById(nativeEvent, state.activePointerId);

    if (touch != null) {
      return doc.elementFromPoint(touch.clientX, touch.clientY);
    } else {
      return null;
    }
  }

  return event.target;
}

function isActivePointer(event, state) {
  var nativeEvent = event.nativeEvent;
  var activePointerId = state.activePointerId;

  if (hasPointerEvents) {
    var eventPointerId = nativeEvent.pointerId;

    if (activePointerId != null && eventPointerId != null) {
      return state.pointerType === event.pointerType && activePointerId === eventPointerId;
    } else {
      return true;
    }
  } else {
    if (event.pointerType === 'touch') {
      var touch = getTouchById(nativeEvent, activePointerId);
      return touch != null;
    } else {
      // accept all events that don't have ids
      return true;
    }
  }
}

function isModifiedTap(event) {
  var nativeEvent = event.nativeEvent;
  var altKey = nativeEvent.altKey,
      ctrlKey = nativeEvent.ctrlKey,
      metaKey = nativeEvent.metaKey,
      shiftKey = nativeEvent.shiftKey;
  return altKey === true || ctrlKey === true || metaKey === true || shiftKey === true;
}

function shouldActivate(event) {
  var nativeEvent = event.nativeEvent;
  var pointerType = event.pointerType;
  var buttons = nativeEvent.buttons;
  var isContextMenu = pointerType === 'mouse' && nativeEvent.ctrlKey && isMac;
  var isValidButton = buttons === buttonsEnum.primary || buttons === buttonsEnum.middle;

  if (pointerType === 'touch' || isValidButton && !isContextMenu) {
    return true;
  } else {
    return false;
  }
}
/**
 * Communicating gesture state back to components
 */


function dispatchStart(context, props, state) {
  var type = 'tap:start';
  var onTapStart = props.onTapStart;

  if (onTapStart != null) {
    var payload = _assign({}, state.gestureState, {
      type: type
    });

    dispatchDiscreteEvent(context, payload, onTapStart);
  }
}

function dispatchChange(context, props, state) {
  var onTapChange = props.onTapChange;

  if (onTapChange != null) {
    var payload = state.isActive;
    dispatchDiscreteEvent(context, payload, onTapChange);
  }
}

function dispatchUpdate(context, props, state) {
  var type = 'tap:update';
  var onTapUpdate = props.onTapUpdate;

  if (onTapUpdate != null) {
    var payload = _assign({}, state.gestureState, {
      type: type
    });

    dispatchUserBlockingEvent(context, payload, onTapUpdate);
  }
}

function dispatchEnd(context, props, state) {
  var type = 'tap:end';
  var onTapEnd = props.onTapEnd;

  if (onTapEnd != null) {
    var payload = _assign({}, state.gestureState, {
      type: type
    });

    dispatchDiscreteEvent(context, payload, onTapEnd);
  }
}

function dispatchCancel(context, props, state) {
  var type = 'tap:cancel';
  var onTapCancel = props.onTapCancel;

  if (onTapCancel != null) {
    var payload = _assign({}, state.gestureState, {
      type: type
    });

    dispatchDiscreteEvent(context, payload, onTapCancel);
  }
}
/**
 * Responder implementation
 */


var responderImpl = {
  targetEventTypes: targetEventTypes,
  getInitialState: function () {
    return createInitialState();
  },
  onEvent: function (event, context, props, state) {
    if (props.disabled) {
      removeRootEventTypes(context, state);

      if (state.isActive) {
        dispatchCancel(context, props, state);
        state.isActive = false;
      }

      return;
    }

    var nativeEvent = event.nativeEvent;
    var eventTarget = nativeEvent.target;
    var eventType = event.type;

    switch (eventType) {
      // START
      case 'pointerdown':
      case 'mousedown':
      case 'touchstart':
        {
          if (hasPointerEvents) {
            var pointerId = nativeEvent.pointerId;
            state.activePointerId = pointerId; // Make mouse and touch pointers consistent.
            // Flow bug: https://github.com/facebook/flow/issues/8055
            // $FlowExpectedError

            eventTarget.releasePointerCapture(pointerId);
          } else {
            if (eventType === 'touchstart') {
              var targetTouches = nativeEvent.targetTouches;

              if (targetTouches.length > 0) {
                state.activePointerId = targetTouches[0].identifier;
              }
            }

            if (eventType === 'mousedown' && state.ignoreEmulatedEvents) {
              return;
            }
          }

          if (!state.isActive && shouldActivate(event)) {
            state.isActive = true;
            state.buttons = nativeEvent.buttons;
            state.pointerType = event.pointerType;
            state.responderTarget = context.getResponderNode();
            state.shouldPreventClick = props.preventDefault !== false;
            state.gestureState = createGestureState(context, props, state, event);
            dispatchStart(context, props, state);
            dispatchChange(context, props, state);
            addRootEventTypes(rootEventTypes, context, state);

            if (!hasPointerEvents) {
              if (eventType === 'touchstart') {
                state.ignoreEmulatedEvents = true;
              }
            }
          }

          break;
        }
    }
  },
  onRootEvent: function (event, context, props, state) {
    var nativeEvent = event.nativeEvent;
    var eventType = event.type;
    var hitTarget = getHitTarget(event, context, state);

    switch (eventType) {
      // MOVE
      case 'pointermove':
      case 'mousemove':
      case 'touchmove':
        {
          if (!hasPointerEvents) {
            if (eventType === 'mousemove' && state.ignoreEmulatedEvents) {
              return;
            }
          }

          if (state.isActive && isActivePointer(event, state)) {
            state.gestureState = createGestureState(context, props, state, event);

            if (context.isTargetWithinResponder(hitTarget)) {
              dispatchUpdate(context, props, state);
            } else {
              state.isActive = false;
              dispatchChange(context, props, state);
              dispatchCancel(context, props, state);
            }
          }

          break;
        }
      // END

      case 'pointerup':
      case 'mouseup':
      case 'touchend':
        {
          if (state.isActive && isActivePointer(event, state)) {
            if (state.buttons === buttonsEnum.middle) {
              // Remove the root events here as no 'click' event is dispatched
              // when this 'button' is pressed.
              removeRootEventTypes(context, state);
            }

            state.gestureState = createGestureState(context, props, state, event);

            if (context.isTargetWithinResponder(hitTarget)) {
              // Determine whether to call preventDefault on subsequent native events.
              if (isModifiedTap(event)) {
                state.shouldPreventClick = false;
              }

              dispatchEnd(context, props, state);
            } else {
              dispatchCancel(context, props, state);
            }

            state.isActive = false;
            dispatchChange(context, props, state);
          }

          if (!hasPointerEvents) {
            if (eventType === 'mouseup') {
              state.ignoreEmulatedEvents = false;
            }
          }

          break;
        }
      // CANCEL

      case 'contextmenu':
      case 'pointercancel':
      case 'touchcancel':
      case 'dragstart':
        {
          if (state.isActive && isActivePointer(event, state)) {
            state.gestureState = createGestureState(context, props, state, event);
            dispatchCancel(context, props, state);
            state.isActive = false;
            dispatchChange(context, props, state);
          }

          break;
        }
      // CANCEL

      case 'scroll':
        {
          if (state.isActive && state.responderTarget != null && // We ignore incoming scroll events when using mouse events
          state.pointerType !== 'mouse' && // If the scroll target is the document or if the pointer target
          // is within the 'scroll' target, then cancel the gesture
          context.isTargetWithinNode(state.responderTarget, nativeEvent.target)) {
            state.gestureState = createGestureState(context, props, state, event);
            dispatchCancel(context, props, state);
            state.isActive = false;
            dispatchChange(context, props, state);
          }

          break;
        }

      case 'click':
        {
          if (state.shouldPreventClick) {
            nativeEvent.preventDefault();
          }

          removeRootEventTypes(context, state);
          break;
        }
    }
  },
  onUnmount: function (context, props, state) {
    removeRootEventTypes(context, state);

    if (state.isActive) {
      dispatchCancel(context, props, state);
      state.isActive = false;
    }
  }
};
var TapResponder = React.unstable_createResponder('Tap', responderImpl);
function useTap(props) {
  return React.unstable_useResponder(TapResponder, props);
}

var Tap = Object.freeze({
	TapResponder: TapResponder,
	useTap: useTap
});

var tap = Tap;

return tap;

})));
